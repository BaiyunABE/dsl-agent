# 详细设计

版本：1.0

日期：2025-11-25

作者：自动生成（基于仓库源码）

---

本文件对 `dsl-agent` 项目的关键类、方法、数据结构、内部流程和使用示例给出详细说明，便于代码审阅、测试和扩展。

**目录**
- 概述
- 关键类与方法说明
  - `DSLEngine`
  - `LLMClient`
  - `main.py`（运行入口）
- 数据结构详解
- 动作执行与条件语义
- 示例调用（代码片段）
- 错误处理与边界情况
- 扩展点与建议
- 测试建议

---

## 概述

系统由三部分组成：
- 意图识别模块（`LLMClient`）：将用户自然语言输入映射到一个意图名称。
- DSL 引擎（`DSLEngine`）：解析 DSL 脚本（`script.dsl`）并根据意图与上下文执行动作序列。
- 入口脚本（`main.py`）：命令行交互，连接意图识别与 DSL 引擎。

下面对每个模块给出详细接口和内部实现要点。

---

## 关键类与方法说明

### DSLEngine

位置：`src/dsl_engine.py`

职责：
- 加载并解析 DSL 脚本（支持 `config`、`var`、`function`、`scene`、`intent` 块）。
- 存储脚本解析结果（场景/意图/动作序列）。
- 执行动作：回复、日志、变量赋值、函数调用、等待输入、信息提取等。
- 管理会话级别的简易状态（`variables`、`waiting_for` 等）。

主要属性：
- `script_file` (str)：脚本路径。
- `scenes` (Dict[str, Dict[str, List[Action]]])：脚本解析后的场景结构。
- `config` (Dict[str, Any])：配置项（如默认场景、超时等）。
- `variables` (Dict[str, Any])：运行时变量表（以 `$var` 语法引用）。
- `functions` (Dict[str, str])：DSL 中的函数映射（字符串标识）。
- `registered_functions` (Dict[str, Callable])：Python 回调函数注册表，供 `call` 使用。
- `waiting_for` (Optional[str])：当前等待的输入类型（例如 `order_number`）。
- `debug` (bool)：是否打印调试信息。

主要方法：
- `__init__(self, script_file, debug=False)`
  - 功能：初始化对象，解析并加载脚本（调用 `_load_script()`）。
  - 注意：相对路径会相对于 `dsl_engine.py` 文件所在目录解析。

- `_load_script(self)`
  - 功能：从文件读取文本并按行解析块结构，填充 `scenes`、`config`、`variables`、`functions`。
  - 要点：当前实现为行解析器（基于字符串方法），对嵌套、引号和复杂表达式有限制。

- `_init_defaults(self)`
  - 功能：设置默认 `config` 与 `variables`，并注册内置示例函数（例如 `get_time`）。

- `register_function(self, name: str, func)`
  - 功能：将 Python 回调注册到 `registered_functions`，以便 `call` 动作直接调用。
  - 使用场景：在主程序或测试中注入自定义实现（例如数据库查询、外部服务调用）。

- `_evaluate_condition(self, condition: str, user_input: str) -> bool`
  - 功能：评估条件表达式，支持 `contains`、`matches`（正则）和常见比较操作符（`==, !=, >, <, >=, <=`）。
  - 实现细节：会替换 `$user_input` 与 `$var`，并使用 `re.fullmatch` 等方式对正则进行匹配；若解析失败会尝试 `eval`（存在安全性风险）。

- `_replace_variables(self, text: str) -> str`
  - 功能：在文本中替换 `$var` 引用为当前 `variables` 中的值（对 `$user_input` 有优先处理）。

- `_process_template(self, text: str) -> str`
  - 功能：处理 DSL 中的模板标记，例如 `{{随机回复:[...]}}`、`{{时间.时间戳}}`、`{{随机数:1-5}}` 等。

- `_safe_eval_expression(self, expr: str)`
  - 功能：对简单算术和字面量表达式做安全评估（使用 `ast` 限制节点类型）。

- `_execute_actions(self, actions, user_input)`
  - 功能：执行给定动作序列（动作为三元组 `(action_type, action_value, condition_stack)`），并返回合并后的回复文本或 `None`。
  - 支持动作类型：`reply`、`log`、`set`、`call`、`wait_for_input`、`wait_for_confirm`、`extract`。
  - 条件栈（`condition_stack`）会在执行前进行判断，只有满足条件（`if` 为 True、`else` 在其 `if` 为 False 的情况下）才会执行动作。

- `get_intents(self) -> List[str]`
  - 功能：返回所有解析到的意图名称（跨场景收集）。

- `process(self, intent: str, user_input: str) -> Optional[str]`
  - 功能：对外处理接口，根据意图寻找对应动作并执行，返回回复文本或默认回复。
  - 多轮处理：若 `waiting_for` 被设置，函数会根据 `waiting_for` 映射替换为特定意图（例如 `order_number` → `provide_order_number`）。

- `get_waiting_status(self)` / `reset_waiting(self)`：获取或重置 `waiting_for` 状态。


### LLMClient

位置：`src/llm_client.py`

职责：
- 将用户自然语言输入映射到 DSL 的意图名称。
- 支持使用外部 LLM API 或本地关键词回退。

主要属性：
- `api_key` (str)：从参数或环境变量 `DSL_AGENT_API_KEY` 读取。
- `client`：OpenAI 兼容的客户端实例（如 `OpenAI(api_key=..., base_url=...)`）。
- `use_llm` (bool)：是否调用真实 LLM。
- `debug` (bool)：调试开关。

主要方法：
- `__init__(self, api_key=None, use_llm=True, debug=False)`：初始化客户端实例。
- `recognize_intent(self, user_input, available_intents)`：高层方法，选择 LLM 或回退算法来选择意图。
- `_llm_recognize_intent(self, user_input, available_intents)`：封装对第三方 LLM 的调用，按提示词（prompt）向模型询问并解析返回结果。
- `_fallback_recognize_intent(self, user_input, available_intents)`：基于关键词的简单匹配策略（对关键词列表进行包含检查并返回第一个匹配意图）。

安全/配置注意：
- 当前实现包含一个默认硬编码 key（建议删除）。建议仅通过环境变量注入 `DSL_AGENT_API_KEY`，并在文档中说明如何获取/配置。
- `base_url` 与 `model` 应作为可配置项（配置文件或环境变量）。


### main.py（运行入口）

位置：`src/main.py`

职责：
- 初始化 `LLMClient` 与 `DSLEngine`，打印可用意图并进入命令行循环。
- 对每条用户输入：使用 `LLMClient` 识别意图，调用 `DSLEngine.process()`，打印机器人回复。

关键流程：
- 读取环境变量 `DSL_DEBUG` 控制调试输出。
- 识别意图后打印识别结果（便于调试）。
- 处理 `退出` / `quit` / `exit` 命令退出程序。


---

## 数据结构详解

### scenes

类型：Dict[str, Dict[str, List[Action]]]

范例：
{
  'main': {
    'greeting': [ ('reply', '你好', []), ('wait_for_input','name',[]) ],
    'provide_name': [ ('extract', 'name from "我叫(.*)"', []), ('reply', '很高兴认识您，$name', []) ]
  },
  'order_management': { ... }
}

解释：最外层按 `scene` 分组，第二层按 `intent` 存储动作列表；每个动作是 `(action_type, action_value, condition_stack)` 三元组，`condition_stack` 用于支持嵌套 `if/else` 语义。

### Action 三元组
- `action_type`：字符串，如 `reply`/`log`/`set`/`call`/`wait_for_input`/`extract`。
- `action_value`：动作的参数（文本、表达式、函数调用字符串等）。
- `condition_stack`：列表，保存该动作所在的 `if/else` 条件堆栈（如 `[('if','$user_input contains "我叫"'), ('else', '$user_input contains "你好"')]`）。

### variables

类型：Dict[str, Any]，用于存储运行时数据，例如用户姓名、上次订单号、计数器等。
引用方式：在脚本中使用 `$var_name`，引擎会在执行中用 `_replace_variables` 替换。

### registered_functions
类型：Dict[str, Callable]
用途：用于将 Python 函数绑定到 DSL 中的 `call` 操作，优先于 DSL 内部 `functions` 映射。

---

## 动作执行与条件语义（更详）

1. 条件栈语义：对于每个动作，执行前会评估其 `condition_stack`：
   - 遇到 `('if', cond_expr)`：若 `cond_expr` 为 False，则跳过动作。
   - 遇到 `('else', cond_expr)`：若对应 `if` 的 `cond_expr` 为 True，则跳过 `else` 下的动作（也即 `else` 在其 `if` 为 False 时才执行）。

2. reply：先调用 `_replace_variables`（替换 `$var` 与 `$user_input`），然后 `_process_template` 处理模板指令。

3. set：解析 `var = expr`，先替换变量引用后尝试 `_safe_eval_expression`，失败时回退为字符串或数值解析。

4. call：解析 `result = func(args)`：
   - 若函数名在 `registered_functions` 中，直接调用回调并将返回值赋给变量。
   - 否则尝试使用 DSL 中 `functions` 映射或内置的简化实现（例如 `get_time`、`validate_order`）。

5. extract：按给定正则或多个模式尝试从 `user_input` 中提取信息，成功则写入变量。

6. wait_for_input / wait_for_confirm：将 `waiting_for` 设置为指定类型，下一条用户输入处理时 `process()` 会检查 `waiting_for` 并将意图映射为预期的“提供”意图（例如 `order_number` → `provide_order_number`）。

---

## 示例调用（代码片段）

以下示例假设当前工作目录为项目根，且可直接 import 模块（与 `src/` 同级）

示例 1：最小化使用

```python
from dsl_engine import DSLEngine
from llm_client import LLMClient

# 初始化
engine = DSLEngine('script.dsl', debug=True)
client = LLMClient(use_llm=False, debug=True)

# 识别意图并处理
user_input = '你好，我想查询我的订单'
intent = client.recognize_intent(user_input, engine.get_intents())
print('识别到意图:', intent)

response = engine.process(intent, user_input)
print('机器人回复:\n', response)
```

示例 2：注册自定义函数并在 DSL 中调用

```python
from dsl_engine import DSLEngine

def my_calc_delivery(order_id):
    # 自定义逻辑，例如调用外部服务
    return '后天下午'

engine = DSLEngine('script.dsl')
engine.register_function('calc_delivery', my_calc_delivery)

# 在脚本中使用 call delivery = calc_delivery($user_input)
resp = engine.process('provide_order_number', 'ORDER123')
print(resp)
```

示例 3：直接调用引擎（跳过 LLM）

```python
engine = DSLEngine('script.dsl')
# 假设用户明确使用 intent 名称
resp = engine.process('check_order', '请查一下订单')
print(resp)
```

---

## 错误处理与边界情况

- 文件不存在：`_load_script()` 捕获 `FileNotFoundError` 并调用 `_create_default_script()` 生成内置脚本。
- 解析错误：`_load_script()` 捕获异常后回退到默认脚本并打印错误信息。
- 条件/正则异常：`_evaluate_condition()` 在捕获 `re.error` 时会返回 False，避免抛出异常中断流程。
- `_safe_eval_expression`：抛出异常会被调用方捕获并回退到默认字符串或数字处理。
- 安全风险：当前实现中 `eval(condition)` 在某些路径可能被使用；建议移除或限制，避免执行任意代码（已在 `_safe_eval_expression` 中限制算术，但 `eval` 仍存在风险）。

---

## 扩展点与建议

- 解析器替换：考虑使用成熟解析库（如 `lark`、`ply` 或 `antlr`）来实现更健壮的语法支持，并生成完整的 AST，便于后续优化与静态检查。
- 会话管理：将 `DSLEngine` 的会话状态抽象为 `Session` 对象，支持多并发会话（例如 web/HTTP 场景）。
- 配置集中化：把 `base_url`、`model`、`timeout`、`debug` 等参数放入 `config` 文件或环境变量，并在 `README.md` 和 `docs/AI_使用说明.md` 中说明。
- 安全强化：完全移除 `eval(condition)`，仅允许受控的表达式语言或在 AST 上做白名单校验。
- 日志替换：将 `print` 替换为 Python `logging`，并提供日志配置（级别、输出到文件/控制台）。
- 单元/API 文档：为主类与方法添加 docstring，并生成 API 文档（例如使用 Sphinx 或 pdoc）。

---

## 测试建议

- 单元测试覆盖：
  - `_evaluate_condition`：包含 `contains`、`matches`、各比较操作、非法正则的处理。
  - `_process_template`：测试随机回复、时间与随机数模板。
  - `_execute_actions`：测试 `reply`、`set`、`call`（包括成功/异常回退）、`extract` 与 `wait_for_input` 行为。
- 集成测试：模拟完整对话流（见 `src/test_dsl_engine.py`），断言关键变量、等待状态与回复文本。
- CI：添加 GitHub Actions 配置以在 Push/PR 时运行 `pytest` 并报告结果。

---

（结束）
